'''
Caleb Eurich
CSCI 3725
M6
4/27/2021

This file executes the poem generation and evaluation. It takes NUM_LINES Dr Seuss syntax trees and generates Young Thug versions
of the lines. Of the generated NUM_POEMS poems, the best poem by sentiment is chosen and preformed. 

Bugs: apostrophes in contractions are spaced out and pronounced wrong by the TTS. 
'''

import pickle
import random
from nltk.sentiment import SentimentIntensityAnalyzer
import win32com.client as wincom

NUM_LINES = 5 #number of lines in a poem
NUM_POEMS = 100 #number of poems generated from which the best is selected

speak = wincom.Dispatch("SAPI.SpVoice")

with open ('pickles/' + 'seuss_trees.pickle', 'rb') as seuss_file:
    seuss_trees = pickle.load(seuss_file)

with open ('pickles/' + 'thug_trees.pickle', 'rb') as thug_file:
    thug_trees = pickle.load(thug_file)

with open ('pickles/' + 'thug_dict.pickle', 'rb') as thug_file2:
    thug_dict = pickle.load(thug_file2)


"""
generate_lines takes a list of syntax trees and a mirror dictionary. This function selects NUM_LINES syntax trees and uses
the generate_line function to generate a line for each syntax tree selected. 

@param all_trees: list of syntax trees created from Dr.Seuss text file
@param mirror_dict: dictionary keyed by syntax tokens with values of song lyric words created from Young Thug text file
@return sentences: list of string lines generated by generate_line loop
"""
def generate_lines(all_trees, mirror_dict):
    sentences = []
    rand_split = random.randint(0, (len(all_trees)-NUM_LINES))
    selected_trees = seuss_trees[rand_split:rand_split + NUM_LINES] #choose NUM_LINES congruent lines
    for tree in selected_trees:
        sentences.append(generate_line(tree, mirror_dict))
    return sentences


"""
generate_line takes a syntax tree and a mirror dictionary. This function keys the mirror dict and generates a sentence that
syntactically matches the original tree but contains words from the mirror_dict 

@param original_tree: syntax tree created from the Dr. Seuss text file
@param mirror_dict: dictionary keyed by syntax tokens with values of song lyric words created from Young Thug text file
@return sentence: string of lyrics that syntactically matches the original tree but contains words from the mirror_dict
"""
def generate_line(original_tree, mirror_dict):
    sentence = ''
    for token in original_tree:
        #print(token)
        #print(token[1])
        if(token[0] in [".", ",", "!", "?", "'"]): #does not put spaces before punctuation
            try:
                sentence += random.choice(mirror_dict[token[1]]) #handles nested tuples in syntax tree
            except:
                sentence += random.choice(mirror_dict[token[0][1]])
        else:
            try:
                sentence += ' ' + random.choice(mirror_dict[token[1]]) #handles nested tuples in syntax tree
            except KeyError:
                sentence #do nothing if token syntax type does not exist in mirror dict keys
            except:
                sentence += ' ' + random.choice(mirror_dict[token[0][1]])
    return sentence


"""
generate_best_poem uses generate lines to generate NUM_POEMS poems then selects the best poem based on sentiment score

@return best_poem: list of strings that is the poem with the best sentiment score
@return best_score: float that is the sentiment score of the best poem. 
"""
def generate_best_poem():
    sia = SentimentIntensityAnalyzer()
    best_poem = []
    best_score = -10
    for i in range(NUM_POEMS): #generate NUM_POEMS poems
        poem = generate_lines(seuss_trees, thug_dict)
        sentiment_score = 0
        for line in poem:
            sentiment_score += sia.polarity_scores(line)['compound']
        sentiment_score = sentiment_score / NUM_LINES #take average for a poem
        if (sentiment_score > best_score):
            best_score = sentiment_score
            best_poem = poem
    return best_poem, best_score


"""
main uses the best poem and score to preform that poem with text to speech before writing the poem and score to a text file. 
"""
def main():
    results = generate_best_poem()
    poem = results[0]
    score = results[1]
    saved_string = ""
    for line in poem:
        saved_string += line + "\n"
        print(line)
        speak.Speak(line)
    score = round(score * 10, 2) #round score to more reasonable number out of -10 to 10
    saved_string += str(score) + "\n\n"
    print("This poem's score is " + str(score))
    speak.Speak("This poem's score is " + str(score))
    with open ('generated_poems/' + 'examples.txt', 'a') as examples_file:
        examples_file.write(saved_string)


if __name__ == "__main__":
    main()